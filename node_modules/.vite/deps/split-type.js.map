{
  "version": 3,
  "sources": ["../../split-type/dist/index.js"],
  "sourcesContent": ["/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.3\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(() => {\n  function append(...nodes) {\n    const length = nodes.length;\n\n    for (let i = 0; i < length; i++) {\n      const node = nodes[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n\n  function replaceChildren(...nodes) {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    if (nodes.length) this.append(...nodes);\n  }\n\n  function replaceWith(...nodes) {\n    const parent = this.parentNode;\n    let i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n\n    while (i--) {\n      let node = nodes[i];\n\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce((extended, key) => {\n    const currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    const newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings = {}) {\n  const object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  let types;\n\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(type => String(type).trim()).filter(type => /((line)|(word)|(char))/i.test(type));\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  const types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  let elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n\n  return toArray(elements).reduce((result, element) => {\n    return [...result, ...toArray(element).filter(isNode)];\n  }, []);\n}\n\nconst {\n  entries,\n  keys,\n  values\n} = Object;\n\nconst expando = `_splittype`;\nconst cache = {};\nlet uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n\n  const id = owner[expando] || (owner[expando] = ++uid);\n  const data = cache[id] || (cache[id] = {});\n\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = { ...data,\n        ...key\n      };\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n\n  return value;\n}\nfunction get(owner, key) {\n  const id = isObject(owner) ? owner[expando] : null;\n  const data = id && cache[id] || {};\n\n  if (key === undefined) {\n    return data;\n  }\n\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  const id = element && element[expando];\n\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(([id, {\n    isRoot,\n    isSplit\n  }]) => {\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value, separator = ' ') {\n  const string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n/** Used to compose unicode capture groups. */\n\nconst rsAstral = `[${rsAstralRange}]`;\nconst rsCombo = `[${rsComboMarksRange}${rsComboSymbolsRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsSymbol = `(?:${[`${rsNonAstral}${rsCombo}?`, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')}\n)`;\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`, 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nconst unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nconst reHasUnicode = RegExp(`[${unicodeRange.join('')}]`);\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */\n\n\nfunction toChars(string, separator = '') {\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  const element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(attribute => {\n    const rawValue = attributes[attribute];\n    const value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append(...toArray(value));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  const types = parseTypes(settings.types); // the tag name for split text nodes\n\n  const TAG_NAME = settings.tagName; // value of the text node\n\n  const VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  const splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  let words = [];\n  let chars = [];\n\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n\n  words = toWords(VALUE).reduce((result, WORD, idx, arr) => {\n    // Let `wordElement` be the wrapped element for the current word\n    let wordElement;\n    let characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(CHAR => {\n        const characterElement = createElement(TAG_NAME, {\n          class: `${settings.splitClass} ${settings.charClass}`,\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [...chars, characterElement];\n        return characterElement;\n      });\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        class: `${settings.wordClass} ${settings.splitClass}`,\n        style: `display: inline-block; ${types.words && settings.absolute ? `position: relative;` : ''}`,\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(characterElement => {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n\n  textNode.replaceWith(splitText);\n  return {\n    words,\n    chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  const type = node.nodeType; // Arrays of split words and characters\n\n  const wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n\n  const childNodes = toArray(node.childNodes);\n\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      const nextSibling = node.nextSibling;\n      const prevSibling = node.previousSibling;\n      const text = node.textContent || '';\n      const textAfter = nextSibling ? nextSibling.textContent : ' ';\n      const textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n\n  return childNodes.reduce((result, child) => {\n    const {\n      words,\n      chars\n    } = split(child, settings);\n    return {\n      words: [...result.words, ...words],\n      chars: [...result.chars, ...chars]\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n\n  const parent = node.offsetParent;\n  const [scrollX, scrollY] = scrollPos;\n  let parentX = 0;\n  let parentY = 0;\n\n  if (parent && parent !== document.body) {\n    const parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n\n  const {\n    width,\n    height,\n    x,\n    y\n  } = node.getBoundingClientRect();\n  const top = y + scrollY - parentY;\n  const left = x + scrollX - parentX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(child => unSplitWords(child));\n  } else {\n    remove(element);\n    element.replaceWith(...element.childNodes);\n  }\n}\n\nconst createFragment = () => document.createDocumentFragment();\n\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  const types = parseTypes(settings.types);\n  const TAG_NAME = settings.tagName;\n  const nodes = element.getElementsByTagName('*');\n  const wordsInEachLine = [];\n  let wordsInCurrentLine = [];\n  let lineOffsetY = null;\n  let elementHeight;\n  let elementWidth;\n  let contentBox;\n  let lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  const parent = element.parentElement;\n  const nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  const splitText = createFragment(); // get the computed style object for the element\n\n  const cs = window.getComputedStyle(element);\n  const align = cs.textAlign;\n  const fontSize = parseFloat(cs.fontSize);\n  const lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n\n  toArray(nodes).forEach(node => {\n    // node is a word element or custom html element\n    const isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    const {\n      width,\n      height,\n      top,\n      left\n    } = getPosition(node, isWordLike, settings, scrollPos); // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top,\n        left,\n        width,\n        height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(wordsInThisLine => {\n      // Create an element to wrap the current line.\n      const lineElement = createElement(TAG_NAME, {\n        class: `${settings.splitClass} ${settings.lineClass}`,\n        style: `display: block; text-align: ${align}; width: 100%;`\n      });\n      set(lineElement, 'isLine', true);\n      const lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach((wordOrElement, idx, arr) => {\n        const {\n          isWordEnd,\n          top,\n          height\n        } = get(wordOrElement);\n        const next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = `${element.style.width || elementWidth}px`;\n    element.style.height = `${elementHeight}px`; // Iterate over all child elements\n\n    toArray(nodes).forEach(node => {\n      const {\n        isLine,\n        top,\n        left,\n        width,\n        height\n      } = get(node);\n      const parentData = get(node.parentElement);\n      const isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = `${isChildOfLineNode ? top - parentData.top : top}px`; // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? `${contentBox.left}px` : `${left - (isChildOfLineNode ? contentBox.left : 0)}px`; // Set the height of the current node to the cached value.\n\n      node.style.height = `${height}px`; //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? `${contentBox.width}px` : `${width}px`; // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return lines;\n}\n\nlet _defaults = extend(defaults, {});\n\nclass SplitType {\n  /**\n   * The internal data store\n   */\n  static get data() {\n    return cache;\n  }\n  /**\n   * The default settings for all splitType instances\n   * @static\n   */\n\n\n  static get defaults() {\n    return _defaults;\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   *\n   * Setting `SplitType.defaults` to an object will merge that object with the\n   * existing defaults.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @deprecated\n   * @static\n   * @example\n   * SplitType.defaults = { \"position\": \"absolute\" }\n   */\n\n\n  static set defaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   * The provided object will be merged with the existing defaults objects.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @returns {Object} the new default settings\n   * @public\n   * @static\n   * @example\n   * SplitType.setDefaults({ \"position\": \"absolute\" })\n   */\n\n\n  static setDefaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n    return defaults;\n  }\n  /**\n   * Revert target elements to their original html content\n   * Has no effect on that\n   *\n   * @param {any} elements The target elements to revert. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @static\n   */\n\n\n  static revert(elements) {\n    getTargetElements(elements).forEach(element => {\n      const {\n        isSplit,\n        html,\n        cssWidth,\n        cssHeight\n      } = get(element);\n\n      if (isSplit) {\n        element.innerHTML = html;\n        element.style.width = cssWidth || '';\n        element.style.height = cssHeight || '';\n        remove(element);\n      }\n    });\n  }\n  /**\n   * Creates a new SplitType instance\n   * This static method provides a way to create a `SplitType` instance without\n   * using the `new` keyword.\n   *\n   * @param {any} target The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   * @return {SplitType} the SplitType instance\n   * @static\n   */\n\n\n  static create(target, options) {\n    return new SplitType(target, options);\n  }\n  /**\n   * Creates a new `SplitType` instance\n   *\n   * @param {any} elements The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   */\n\n\n  constructor(elements, options) {\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  split(options) {\n    // Revert target elements (if they are already split)\n    // Note: revert was already called once in the constructor. However, we\n    // need to call it again here so text is reverted when the user manually\n    // calls the `split` method to re-split text.\n    this.revert(); // Store the original html content of each target element\n\n    this.elements.forEach(element => {\n      set(element, 'html', element.innerHTML);\n    }); // Create arrays to hold the split lines, words, and characters\n\n    this.lines = [];\n    this.words = [];\n    this.chars = []; // cache vertical scroll position before splitting\n\n    const scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n    if (options !== undefined) {\n      this.settings = extend(this.settings, parseSettings(options));\n    }\n\n    const types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n    // @example new SplitType('#target', { types: [] })\n\n    if (types.none) {\n      return;\n    } // Split text in each target element\n\n\n    this.elements.forEach(element => {\n      // Add the split text nodes from this element to the arrays of all split\n      // text nodes for this instance.\n      set(element, 'isRoot', true);\n      const {\n        words,\n        chars\n      } = split(element, this.settings);\n      this.words = [...this.words, ...words];\n      this.chars = [...this.chars, ...chars];\n    });\n    this.elements.forEach(element => {\n      if (types.lines || this.settings.absolute) {\n        const lines = repositionAfterSplit(element, this.settings, scrollPos);\n        this.lines = [...this.lines, ...lines];\n      }\n    }); // Set isSplit to true for the SplitType instance\n\n    this.isSplit = true; // Set scroll position to cached value.\n\n    window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n    cleanup();\n  }\n  /**\n   * Reverts target element(s) back to their original html content\n   * Deletes all stored data associated with the target elements\n   * Resets the properties on the splitType instance\n   *\n   * @public\n   */\n\n\n  revert() {\n    if (this.isSplit) {\n      // Reset instance properties if necessary\n      this.lines = null;\n      this.words = null;\n      this.chars = null;\n      this.isSplit = false;\n    }\n\n    SplitType.revert(this.elements);\n  }\n\n}\n\nexport { SplitType as default };\n"],
  "mappings": "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",
  "names": []
}
